#!/usr/bin/env python3

from __future__ import annotations

import argparse
import json
from dataclasses import asdict, dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any


@dataclass(frozen=True)
class Skill:
    name: str
    description: str
    skill_md_path: str
    command: str
    scripts: list[str]


def _parse_frontmatter(text: str) -> dict[str, str]:
    lines = text.splitlines()
    if not lines or lines[0].strip() != "---":
        return {}

    frontmatter: dict[str, str] = {}
    for line in lines[1:]:
        if line.strip() == "---":
            break
        if ":" not in line:
            continue
        key, value = line.split(":", 1)
        key = key.strip()
        value = value.strip().strip('"').strip("'")
        if key:
            frontmatter[key] = value
    return frontmatter


def _read_text(path: Path, max_bytes: int = 32_768) -> str:
    with path.open("rb") as f:
        data = f.read(max_bytes)
    return data.decode("utf-8", errors="replace")


def _discover_skills(repo_root: Path) -> list[Skill]:
    skills_root = repo_root / ".claude" / "skills"
    skills: list[Skill] = []

    for skill_dir in sorted(skills_root.iterdir()):
        if not skill_dir.is_dir():
            continue
        skill_md = skill_dir / "SKILL.md"
        if not skill_md.is_file():
            continue

        frontmatter = _parse_frontmatter(_read_text(skill_md))
        name = frontmatter.get("name", skill_dir.name).strip()
        description = frontmatter.get("description", "").strip()

        scripts_dir = skill_dir / "scripts"
        scripts: list[str] = []
        if scripts_dir.is_dir():
            scripts = sorted(
                str(p.relative_to(repo_root))
                for p in scripts_dir.rglob("*")
                if p.is_file()
            )

        skills.append(
            Skill(
                name=name,
                description=description,
                skill_md_path=str(skill_md.relative_to(repo_root)),
                command=f"/{name}",
                scripts=scripts,
            )
        )

    skills.sort(key=lambda s: s.name)
    return skills


def _to_markdown(skills: list[Skill]) -> str:
    lines = [
        "# Skills Manifest",
        "",
        "This file is generated by `.claude/scripts/skills-manifest.py`.",
        "",
        "| Skill | Command | Description | File |",
        "|------|---------|-------------|------|",
    ]

    def _escape_pipes(text: str) -> str:
        return text.replace("|", "\\|")

    for s in skills:
        lines.append(
            "| "
            + " | ".join(
                [
                    _escape_pipes(s.name),
                    f"`{s.command}`",
                    _escape_pipes(s.description),
                    f"`{s.skill_md_path}`",
                ]
            )
            + " |"
        )

    lines.append("")
    return "\n".join(lines)


def _to_json(repo_root: Path, skills: list[Skill]) -> dict[str, Any]:
    _ = repo_root
    return {"schema_version": 1, "skills": [asdict(s) for s in skills]}


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Enumerate .claude/skills/*/SKILL.md into a manifest."
    )
    parser.add_argument(
        "--format",
        choices=["md", "json"],
        default="md",
        help="Output format (default: md).",
    )
    parser.add_argument(
        "--include-generated-at",
        action="store_true",
        help="Include a generated_at timestamp in JSON output.",
    )
    parser.add_argument(
        "--write",
        action="store_true",
        help="Write .claude/skills/manifest.{md,json} in addition to printing.",
    )
    args = parser.parse_args()

    repo_root = Path(__file__).resolve().parents[2]
    skills = _discover_skills(repo_root)

    md = _to_markdown(skills)
    j = _to_json(repo_root, skills)
    if args.include_generated_at:
        j = {
            **j,
            "generated_at": datetime.now(timezone.utc).isoformat(),
        }

    if args.write:
        skills_root = repo_root / ".claude" / "skills"
        (skills_root / "manifest.md").write_text(md + "\n", encoding="utf-8")
        (skills_root / "manifest.json").write_text(
            json.dumps(j, indent=2, sort_keys=True) + "\n",
            encoding="utf-8",
        )

    if args.format == "json":
        print(json.dumps(j, indent=2, sort_keys=True))
    else:
        print(md)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
